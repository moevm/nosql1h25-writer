# Работа с авторизацией в проекте
## Общие сведения

Используется механизм `accessToken` + `refreshToken`. Суть в том, что `accessToken` короткоживущий и было бы неудобно каждые 30 минут заново логиниться через ручку `/auth/login` (здесь и дальше рассматриваются пути на бэке, с фронта к ним еще прибавляется префикс `api`), поэтому для предотвращения этого есть `refreshToken`, с помощью которого по ручке `/auth/refresh` можно обновить пару токенов незаметно от юзера. Кроме того, это позволяет быть залогиненым на разных устройствах, в разных браузерах и тд именно за счет того, что под сессию долгоживущую (в нашем случае это месяц) выделяется отдельный `refreshToken`.

Механизм работы нашей системы примерно такой:
- `/auth/login` позволяет залогиниться по данным пользователя, которые передаются в теле POST запроса. Возращается `accessToken` и `refreshToken` (рефреш еще проставляется в http-only cookie, чем мы и будем пользоваться, а возврат в теле нужен для того, если вдруг будет мобильное приложение, где понятия нормальных кук нет). `accessToken` живет 30 минут и в нем закодированы данные о `userID` и `systemRole` и именно он подставляется в заголовок Authorization в виде `Bearer <тут сам токен>` всех будущих HTTP-запросов на "защищенные" авторизацией ручки. `accessToken` фронту можно сохранить у себя локально, в то время как `refreshToken` летает по кукам и причем только на `/auth` роуты и его надо максимально не палить. `refreshToken` живет 30 дней, но как его использовать рассмотрим в следующих пунктах
- возникает вопрос, "а что делать по истечению 30 минут?". Ответ таков: посмотреть, что `accessToken` действительно протух, отослать `refreshToken` на `/auth/refresh` и получить новую пару токенов, причем отправленный в запросе `refreshToken` станет невалидным и надо будет использовать тот, что придет в ответе. То есть по сути потребность логиниться заново может потребоваться только если 30 дней не заходить на сайт, потому что протухнут уже оба токена, в остальных же случаях можно получить новую пару незаметно для клиента (этим будет заниматься код на фронте)
- на будущее также предусмотрен ендпоинт `/auth/logout`, который позволяет дропнуть сессию по `refreshToken`, с помощью этого в случае утечки рефреша можно будет подропать все сессии и дать залогиниться только реальному юзеру