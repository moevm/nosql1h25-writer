// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	entity "github.com/moevm/nosql1h25-writer/backend/internal/entity"
	mock "github.com/stretchr/testify/mock"

	orders "github.com/moevm/nosql1h25-writer/backend/internal/repo/orders"

	primitive "go.mongodb.org/mongo-driver/bson/primitive"
)

// Repo is an autogenerated mock type for the Repo type
type Repo struct {
	mock.Mock
}

// Create provides a mock function with given fields: ctx, in
func (_m *Repo) Create(ctx context.Context, in orders.CreateIn) (primitive.ObjectID, error) {
	ret := _m.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 primitive.ObjectID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, orders.CreateIn) (primitive.ObjectID, error)); ok {
		return rf(ctx, in)
	}
	if rf, ok := ret.Get(0).(func(context.Context, orders.CreateIn) primitive.ObjectID); ok {
		r0 = rf(ctx, in)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(primitive.ObjectID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, orders.CreateIn) error); ok {
		r1 = rf(ctx, in)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateResponse provides a mock function with given fields: ctx, orderID, userID, coverLetter, freelancerName
func (_m *Repo) CreateResponse(ctx context.Context, orderID primitive.ObjectID, userID primitive.ObjectID, coverLetter string, freelancerName string) error {
	ret := _m.Called(ctx, orderID, userID, coverLetter, freelancerName)

	if len(ret) == 0 {
		panic("no return value specified for CreateResponse")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, primitive.ObjectID, primitive.ObjectID, string, string) error); ok {
		r0 = rf(ctx, orderID, userID, coverLetter, freelancerName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Find provides a mock function with given fields: ctx, offset, limit, minCost, maxCost, sortBy
func (_m *Repo) Find(ctx context.Context, offset int, limit int, minCost *int, maxCost *int, sortBy *string) (orders.FindOut, error) {
	ret := _m.Called(ctx, offset, limit, minCost, maxCost, sortBy)

	if len(ret) == 0 {
		panic("no return value specified for Find")
	}

	var r0 orders.FindOut
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, *int, *int, *string) (orders.FindOut, error)); ok {
		return rf(ctx, offset, limit, minCost, maxCost, sortBy)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, *int, *int, *string) orders.FindOut); ok {
		r0 = rf(ctx, offset, limit, minCost, maxCost, sortBy)
	} else {
		r0 = ret.Get(0).(orders.FindOut)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, *int, *int, *string) error); ok {
		r1 = rf(ctx, offset, limit, minCost, maxCost, sortBy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByUserIDExt provides a mock function with given fields: ctx, userID
func (_m *Repo) FindByUserIDExt(ctx context.Context, userID primitive.ObjectID) ([]entity.OrderExt, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for FindByUserIDExt")
	}

	var r0 []entity.OrderExt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, primitive.ObjectID) ([]entity.OrderExt, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, primitive.ObjectID) []entity.OrderExt); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.OrderExt)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, primitive.ObjectID) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByID provides a mock function with given fields: ctx, id
func (_m *Repo) GetByID(ctx context.Context, id primitive.ObjectID) (orders.OrderWithClientData, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 orders.OrderWithClientData
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, primitive.ObjectID) (orders.OrderWithClientData, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, primitive.ObjectID) orders.OrderWithClientData); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(orders.OrderWithClientData)
	}

	if rf, ok := ret.Get(1).(func(context.Context, primitive.ObjectID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByIDExt provides a mock function with given fields: ctx, id
func (_m *Repo) GetByIDExt(ctx context.Context, id primitive.ObjectID) (entity.OrderExt, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetByIDExt")
	}

	var r0 entity.OrderExt
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, primitive.ObjectID) (entity.OrderExt, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, primitive.ObjectID) entity.OrderExt); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(entity.OrderExt)
	}

	if rf, ok := ret.Get(1).(func(context.Context, primitive.ObjectID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: ctx, in
func (_m *Repo) Update(ctx context.Context, in orders.UpdateIn) error {
	ret := _m.Called(ctx, in)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, orders.UpdateIn) error); ok {
		r0 = rf(ctx, in)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewRepo creates a new instance of Repo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRepo(t interface {
	mock.TestingT
	Cleanup(func())
}) *Repo {
	mock := &Repo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
